# 8-数据管理

## volume

容器和Pod的生命周期可能很短，会被频繁地销毁和创建。容器销毁时，保存在容器内部文件系统中的数据都会被清除。为了持久化保存容器的数据，可以使用Kubernetes Volume。

Volume的生命周期独立于容器，Pod中的容器可能被销毁和重建，但Volume会被保留。本质上，Kubernetes Volume是一个目录，当Volume被mount到Pod，Pod中的所有容器都可以访问这个Volume。

### emptyDir

emptyDir是最基础的Volume类型。正如其名字所示，一个emptyDir Volume是Host上的一个空目录。

emptyDir Volume对于容器来说是持久的，对于Pod则不是。当Pod从节点删除时，Volume的内容也会被删除。但如果只是容器被销毁而Pod还在，则Volume不受影响。也就是说：emptyDir Volume的生命周期与Pod一致。Pod中的所有容器都可以共享Volume，它们可以指定各自的mount路径。

**实践**

```yaml
# vi test.yaml
apiVersion: v1
kind: Pod
metadata:
  name: producer-consumer
spec:
  containers:
  - image: busybox
    name: producer
    volumeMounts:
    - mountPath: /producer_dir
      name: shared-volume
    args:
    - /bin/sh
    - -c
    - echo "hello world" > /producer_dir/hello;sleep 30000
    
  - image: busybox
    name: consumer
    volumeMounts:
    - mountPath: /consumer_dir
      name: shared-volume
    args:
    - /bin/sh
    - -c
    - cat /consumer_dir/hello ; sleep 30000

  volumes:
  - name: shared-volume
    emptyDir: {}
```

这里我们模拟了一个producer-consumer场景。Pod有两个容器producer和consumer，它们共享一个Volume。producer负责往Volume中写数据，consumer则是从Volume读取数据。

- 文件最底部volumes定义了一个emptyDir类型的Volume shared-volume。
- producer容器将shared-volume mount到/producer_dir目录。
- producer通过echo将数据写到文件hello里。
- consumer容器将shared-volume mount到/consumer_dir目录。
- consumer通过cat从文件hello读数据。

**执行命令创建Pod**

```shell
root@host3:~# kubectl apply -f test.yaml
pod/producer-consumer created
root@host3:~# kubectl get pod
NAME                            READY   STATUS      RESTARTS         AGE
producer-consumer               2/2     Running     0                15s
root@host3:~# kubectl logs producer-consumer consumer
hello world
```

使用kubectl logs显示容器consumer成功读到了producer写入的数据，验证了两个容器共享emptyDir Volume。因为emptyDir是Docker Host文件系统里的目录，其效果相当于执行了docker run -v  /producer_dir和docker run -v  /consumer_dir

emptyDir是Host上创建的临时目录，其优点是能够方便地为Pod中的容器提供共享存储，不需要额外的配置，它不具备持久性，如果Pod不存在了，emptyDir也就没有了。

### hostPath

hostPath Volume的作用是将Docker Host文件系统中已经存在的目录mount给Pod的容器

大部分应用都不会使用hostPath Volume，因为这实际上增加了Pod与节点的耦合，限制了Pod的使用,不过那些需要访问Kubernetes或Docker内部数据的应用则需要使用hostPath

